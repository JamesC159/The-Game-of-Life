# Conway's Game of Life with Gosper's Glider Gun
This is a React front-end and Express.js backend API implementation of the Game of Life.
## How to install and run
* Download or clone the repository
* Ensure you have Node.js installed (The version used in this project is 15.12.0)
* Navigate to the api directory
    * Run `npm install` to install depenedencies
    * You can now run `npm start` to start the Express.js back-end
* Navigate to the gospers-gun directory
    * Again, run `npm install` to install dependencies
    * Again, you can now run You can now run `npm start` to start the React front-end
* Open a browser and enter the URL `localhost:3000`.
## Difficulties:
I had a lot of trouble trying to figure out how to support a world as big as 2^64 x 2^64. Javascript only supports 32 bit objects and Chrome (where my testing was done) only supports a maximum of 4GB of RAM. This led me to ideas such as creating my own data types that allowed me to juggle around multiple arrays / buffers / chunking data to simulate a field that could possibly support that big of a configuration (even though Chrome wouldn't allow it).<br/><br/>
I decided to abandon this idea and continue with the default Javascript object size limits due to space constraints and remain focused on more pressing issues. A point can be made here, that processing something that big is impractical, as it is supposed to be rendered quickly since it is the main component of the UI/UX. It would take a very long time for the user to see it. Something that big to be processed should be data that isn't needed often, or can be processed asynchronously in the background without the user caring about it or knowing it is happening. With massive amounts of data processing, a cloud could be used for this.<br/><br/>
I also had some troubles trying to generate the Gosper's Glider Gun to display correctly into an MxN field. This was mostly a CSS problem.<br/><br/>
On Sunday 03/28/2021 (the last day) around 12am midnight. I had a problems trying to get the sibling components of the ```Field``` component to syncronize their states with a new HTML canvas enhancement. Particularly when you change the size of the board to an MxN configuration. This was due to lack of React expertise on my part I believe. The ```Field``` component continued to act like the rows and columns were still squared even when I input something like 60 rows / 50 columns. The canvas would draw them as if the field was still in the previous rows / columns state before the ```drawCells()``` callback happened. I tried many different ways to update the ```Field``` component corerctly, such as passing all modified state from the ```Board``` component down to the ```Field``` component through props and utlizing callbacks to ensure that the ```Field``` component state was up to date, tying state of the ```Field``` component back into the paranet ```Board``` component to try and trick React into believing things had changed, and many other scenarios that may not have been best practice. Any squared field configuration worked correctly (200x200, 1000x1000, etc). This proved to be an elusive bug for me at this time of night. I understood the issue, but had trouble finding the solution. I feel like with another set of eyes/person to consult with more expertise in React or some sleep with time to solve the issue the next day, this would not have been a sumbitted issue. Lack of energy can be a real issue sometimes with programmers. __The next morning, I solved the issue. Dreams can be helpful!__<br/><br/>
I had quite a few difficulties dealing with the toroidal surface problem. Most of them were due to trying to use modulus in ways that I haven't used in quite some time, along with a new understanding of how to create toroidal surfaces. after debugging for about a day and redesigning for about a day, I decided to opt for a simpler solution by creating a wrap around function that calculated the wrap around index for the top, bottom, left, and right boundaries of the matrix. With a little bit more code, we gain a lot of readability which in turn promotes maintainability.<br/><br/>
## Lessons Learned:
1. I learned the limits of the javascript language when it comes to object size.
1. I learned the limitations of browser RAM, as this has never been an issue I've needed to face in the professional world.
